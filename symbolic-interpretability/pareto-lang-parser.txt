"""
🜏 Pareto Language Parser 🜏

This module provides the parser for the pareto-lang interpretability command language.
Pareto-lang is a domain-specific language designed for transformer model interpretability,
using the `.p/` command prefix format.

The language follows the syntax:
.p/<command_family>/<function>{parameters}

Examples:
.p/reflect.trace{depth=complete, target=reasoning}
.p/fork.attribution{sources=all, visualize=true}
.p/collapse.detect{trigger=recursive_depth, threshold=0.7}
.p/anchor.recursive{level=5, persistence=0.92}

This parser handles the tokenization, parsing, and validation of these commands,
generating structured command objects that can be executed by the interpreter.

.p/reflect.trace{depth=complete, target=syntax}
.p/collapse.prevent{trigger=recursive_depth, threshold=5}
"""

import re
import json
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple, Union

from .syntax import (
    COMMAND_FAMILIES,
    COMMAND_FUNCTIONS,
    PARAMETER_TYPES,
    PARAMETER_VALIDATORS,
)


class TokenType(Enum):
    """Token types in pareto-lang syntax."""
    PREFIX = "prefix"               # .p/
    COMMAND_FAMILY = "command_family"  # reflect, fork, collapse, etc.
    SEPARATOR = "separator"         # . or /
    FUNCTION = "function"           # trace, attribution, detect, etc.
    PARAM_START = "param_start"     # {
    PARAM_END = "param_end"         # }
    PARAM_NAME = "param_name"       # depth, target, etc.
    PARAM_ASSIGN = "param_assign"   # =
    PARAM_VALUE = "param_value"     # complete, reasoning, etc.
    PARAM_SEPARATOR = "param_separator"  # ,
    ERROR = "error"                 # Invalid token
    EOF = "eof"                     # End of command


class Token:
    """
    Represents a parsed token in the pareto-lang command syntax.
    
    ∴ Tokens are the symbolic residue of the parsing process ∴
    """
    def __init__(self, token_type: TokenType, value: str, position: int):
        """
        Initialize a token with its type, value, and position.
        
        Args:
            token_type: Type of token
            value: String value of the token
            position: Position in the input string
        """
        self.type = token_type
        self.value = value
        self.position = position
    
    def __repr__(self) -> str:
        """String representation of the token."""
        return f"Token({self.type}, '{self.value}', {self.position})"


class ParseError(Exception):
    """
    Exception raised when parsing pareto-lang commands fails.
    
    🝚 Errors are persistent semantic signals, not just failures 🝚
    """
    def __init__(self, message: str, position: int, command: str):
        """
        Initialize a parse error with message, position, and command.
        
        Args:
            message: Error message
            position: Position in the command where the error occurred
            command: Original command string
        """
        self.position = position
        self.command = command
        
        # Create a pointer to the error position
        pointer = " " * position + "^"
        
        # Enhance error message with position context
        enhanced_message = f"{message}\n{command}\n{pointer}"
        super().__init__(enhanced_message)


class CommandObject:
    """
    Represents a parsed pareto-lang command ready for execution.
    
    ⧖ Command objects stabilize the interface between parsing and execution ⧖
    """
    def __init__(
        self,
        command_family: str,
        function: str,
        parameters: Dict[str, Any],
        original_command: str,
    ):
        """
        Initialize a command object.
        
        Args:
            command_family: The command family (reflect, fork, etc.)
            function: The specific function (trace, attribution, etc.)
            parameters: Dictionary of parameter names to values
            original_command: The original command string
        """
        self.command_family = command_family
        self.function = function
        self.parameters = parameters
        self.original_command = original_command
    
    def __repr__(self) -> str:
        """String representation of the command object."""
        params_str = ", ".join(f"{k}={repr(v)}" for k, v in self.parameters.items())
        return f"CommandObject({self.command_family}.{self.function}, {{{params_str}}})"


class Parser:
    """
    Parser for pareto-lang interpretability commands.
    
    This class handles tokenization, parsing, and validation of pareto-lang
    commands, converting them into executable command objects.
    
    ↻ The parser recursively analyzes the command structure ↻
    """
    
    def __init__(self):
        """
        Initialize the parser with syntax definitions.
        
        🜏 Parser initialization reflects the language structure it will parse 🜏
        """
        # Compiled regex patterns for tokenization
        self.patterns = {
            TokenType.PREFIX: re.compile(r'\.p/'),
            TokenType.COMMAND_FAMILY: re.compile(r'[a-z_]+'),
            TokenType.SEPARATOR: re.compile(r'[./]'),
            TokenType.FUNCTION: re.compile(r'[a-z_]+'),
            TokenType.PARAM_START: re.compile(r'{'),
            TokenType.PARAM_END: re.compile(r'}'),
            TokenType.PARAM_NAME: re.compile(r'[a-z_]+'),
            TokenType.PARAM_ASSIGN: re.compile(r'='),
            TokenType.PARAM_VALUE: re.compile(r'[^,}]+'),
            TokenType.PARAM_SEPARATOR: re.compile(r','),
        }
    
    def parse(self, command: str) -> CommandObject:
        """
        Parse a pareto-lang command string into a command object.
        
        Args:
            command: The command string to parse
            
        Returns:
            Parsed command object
            
        Raises:
            ParseError: If the command syntax is invalid
            
        ⇌ The parsing process bidirectionally maps syntax to semantics ⇌
        """
        # Tokenize the command
        tokens = self._tokenize(command)
        
        # Initialize parsing state
        current_index = 0
        command_family = None
        function = None
        parameters = {}
        
        try:
            # Expect .p/ prefix
            if current_index >= len(tokens) or tokens[current_index].type != TokenType.PREFIX:
                raise ParseError("Expected '.p/' prefix", tokens[current_index].position if current_index < len(tokens) else 0, command)
            current_index += 1
            
            # Expect command family
            if current_index >= len(tokens) or tokens[current_index].type != TokenType.COMMAND_FAMILY:
                raise ParseError("Expected command family", tokens[current_index].position if current_index < len(tokens) else len(command), command)
            command_family = tokens[current_index].value
            current_index += 1
            
            # Validate command family
            if command_family not in COMMAND_FAMILIES:
                raise ParseError(f"Unknown command family: {command_family}", tokens[current_index - 1].position, command)
            
            # Expect separator
            if current_index >= len(tokens) or tokens[current_index].type != TokenType.SEPARATOR:
                raise ParseError("Expected '.' separator", tokens[current_index].position if current_index < len(tokens) else
